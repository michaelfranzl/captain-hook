{"version":3,"sources":["captain-hook.js"],"names":["CaptainHook","_impl","_ref","arguments","length","undefined","_ref$on_prop","on_prop","_ref$once_prop","once_prop","_ref$off_prop","off_prop","_ref$emit_prop","emit_prop","_ref$handlers_prop","handlers_prop","privatehandlers","impl","eventname","callable","options","handler","tag","priority","context","this","once","handlers","push","sort","a","b","_defineProperty","eventhandlers","i","found","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","value","err","return","splice","retvals","_len","args","Array","_key","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_eventhandler$callabl","eventhandler","call","apply","concat","Object","assign","create","prototype"],"mappings":"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","sourcesContent":["/*\ncaptain-hook\n\nA configurable mix-in providing flexible event emission for JavaScript objects.\n\nCopyright 2017 Michael Karl Franzl\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/**\n * @param {Object} config - Names to use for the property names of the\n * returned object.\n * @param {String} config.on_prop - Method property name for setting event\n * handlers. Defaults to '_on'.\n * @param {String} config.off_prop - Method property name for removing event\n * handlers. Defaults to '_off'.\n * @param {String} config.emit_prop - Method property name for calling event\n * handlers. Defaults to '_emit'.\n * @param {String|null} config.handlers_prop - Property name for storing event\n * handlers. Defaults to '_handlers'. If `null`, a privately scoped storage will\n * be used, in which case you need to mix in CaptainHook into every instance,\n * otherwise event handlers would be shared across instances.\n */\nvar CaptainHook = function ({\n  on_prop        = 'on',\n  once_prop      = 'once',\n  off_prop       = 'off',\n  emit_prop      = '_emit',\n  handlers_prop  = '_handlers',\n} = {}) {\n  \n  let privatehandlers;\n  if (handlers_prop == null) {\n    // Use a private storage for event handlers instead of a\n    // publicly accessible one.\n    privatehandlers = {};\n  }\n  \n  // This is the plain object that you will be able to mix-in to\n  // your own instances or prototypes.\n  let impl = {\n    \n    /**\n     * Add an event handler to an event name.\n     * \n     * The name of this method is configurable via the factory function.\n     * \n     * @param {String} eventname\n     * @param {Function} callable\n     * @param {Object} options\n     * @param {String} options.tag - Name tag of handler\n     * @param {Number} options.priority - Execution order of handlers is sorted\n     * by this number.\n     * @param {Object} options.context - Value to use for the first argument of\n     * `Function.call()` when calling `handler`, changing the meaning of `this`\n     * inside `handler`. By default `this` in the `handler` is the object which\n     * emitted the event.\n     * @param {boolean} options.once - set to `true` if `handler` should only\n     * be ran once. Defaults to `false`.\n     */\n    [on_prop] (eventname, callable, options={}) {\n      let handler = {\n        callable: callable,\n        tag: options.tag,\n        priority: options.priority || 10,\n        context: options.context || this,\n        once: options.once || false,\n      };\n\n      // Choose and initialize the handlers storage\n      let handlers;\n      if (handlers_prop) {\n        if (!this[handlers_prop]) {\n          // Only ran once.\n          // `this` will be the instance, not the prototype.\n          this[handlers_prop] = {};\n        }\n        handlers = this[handlers_prop];\n      } else {\n        // Use the privately scoped storage instead.\n        handlers = privatehandlers;\n      }\n      \n      if (!handlers[eventname]) {\n        handlers[eventname] = [handler];\n      } else {\n        handlers[eventname].push(handler);\n      }\n      handlers[eventname].sort(function(a, b) {\n        return b.priority - a.priority\n      });\n    },\n    \n    \n    /**\n     * Add an one-time event handler to an event name.\n     * \n     * The name of this method is configurable via the factory function.\n     * \n     * Receives the same arguments as `on`, but sets `options.once` to `true`.\n     */\n    [once_prop] (eventname, callable, options={}) {\n      options.once = true;\n      this[on_prop](eventname, callable, options);\n    },\n    \n    \n    /**\n     * Remove an event handler named `tag` from `eventname`.\n     * \n     * The name of this method is configurable via the factory function.\n     * \n     * @param {String} eventname\n     * @param {String} tag\n     * \n     * If `tag` or `eventname` are not registered, this method does nothing.\n     */\n    [off_prop] (eventname, tag) {\n      // Choose the handlers storage.\n      let handlers;\n      if (handlers_prop) {\n        handlers = this[handlers_prop];\n      } else {\n        handlers = privatehandlers;\n      }\n      \n      if (!tag || !handlers || !handlers[eventname]) {\n        // Nothing to do.\n        return\n      }\n      \n      let eventhandlers = handlers[eventname];\n      \n      // Find the event handler with matching tag in the array.\n      let i = 0;\n      let found = false;\n      for (let eventhandler of eventhandlers) {\n        if (eventhandler.tag == tag) {\n          found = true;\n          break;\n        }\n        i++;\n      }\n      if (found) {\n        // Remove this handler\n        eventhandlers.splice(i, 1);\n      }\n    },\n    \n    \n    /**\n     * Call event handlers with the provided arguments.\n     * \n     * The name of this method is configurable via the factory function.\n     * \n     * @param {String} eventname\n     * @param {...} args - Arguments to call the handler with.\n     * @return {Array} - Each return value of handlers concatenated.\n     * \n     * Note that return values of event handlers are not visible to\n     * any other event handler, which provides isolation between\n     * event handlers as well as privacy.\n     * \n     * To implement content filtering, you need to pass the content\n     * by reference (i.e. to filter strings, you need to wrap the\n     * string into an object or array).\n     */\n    [emit_prop] (eventname, ...args) {\n      // Choose the handlers storage.\n      let handlers;\n      if (handlers_prop) {\n        handlers = this[handlers_prop];\n      } else {\n        handlers = privatehandlers;\n      }\n      \n      let retvals = [];\n      if (!handlers || !handlers[eventname]) {\n        // Nothing to do\n        return retvals\n      }\n      \n      for (let eventhandler of handlers[eventname]) {\n        retvals.push(eventhandler.callable.call(eventhandler.context, ...args));\n      }\n      \n      // remove one-time event handlers\n      for (let i = handlers[eventname].length - 1; i >= 0; i--) {\n        let handler = handlers[eventname][i];\n        if (handler.once) {\n          handlers[eventname].splice(i, 1);\n        }\n      }\n      \n      return retvals;\n    },\n    \n  } // end impl\n  \n  return Object.assign(Object.create(CaptainHook.prototype), impl);\n};\n\nexport default CaptainHook;\n"]}