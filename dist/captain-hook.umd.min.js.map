{"version":3,"file":"captain-hook.umd.min.js","sources":["../src/captain-hook.js"],"sourcesContent":["/*jshint esversion: 6 */\n\n/*\ncaptain-hook\n\nA configurable mix-in providing flexible event emission for JavaScript objects.\n\nCopyright 2017 Michael Karl Franzl\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/** \n * Callback function consuming an event.\n * \n * @callback {Function} EventHandler\n * @param {...*} args - Arguments provided by the emitter of the event ({@link EmitEvent}).\n * @returns {*} Optionally returned values of attached EventHandlers\n * are concatenated into an Array and passed back to the {@link EmitEvent}.\n */\n\n\n\n/**\n* Object implementing event emitter behavior which can be mixed into other\n* objects, classes, or prototypes. See README for illustrations.\n* \n* @typedef {Object} EventEmitter\n* @property {AddEventHandler} on Associates an event handler function\n* with an event name.\n* @property {AddOneTimeEventHandler} once Same as {@link AddEventHandler}, but sets `options.once` to `true`.\n* @property {RemoveEventHandler} off Remove an event listener.\n* @property {EmitEvent} _emit Call all registered event\n* handlers.\n*/\n\n\n/**\n * Factory returning a plain object implementing event emission behavior.\n * \n * The default method/property names for adding and removing handlers are\n * `on()`, `off()`, and `_emit()`. The attached event handler functions are\n * stored in a property named `_handlers`.\n * \n * All property/method names can be explicitly configured via `config` to\n * prevent naming conflicts with existing propety names of the target object.\n * \n * @example\n * let event_emitter = CaptainHook({\n *   on_prop:       'on',       // public\n *   off_prop:      'off',      // public\n *   emit_prop:     '_emit',    // pseudo-private\n *   handlers_prop: '_handlers' // pseudo-private\n * });\n * \n * @param {Object} [config={}] Property names of the returned object.\n * @param {String} [config.on_prop=on] Method property name for setting event\n * handlers.\n * @param {String} [config.off_prop=off] Method property name for removing event\n * handlers.\n * @param {String} [config.emit_prop=_emit] Method property name for calling\n * event handlers.\n * @param {(String|null)} [config.handlers_prop=_handlers] Property name for\n * storage of event handlers. If `null`, a truly private storage will\n * be used, in which case you need to mix the EventEmitter into every instance,\n * otherwise event handlers would be shared across instances.\n * @returns {EventEmitter}\n */\nvar CaptainHook = function ({\n  on_prop        = 'on',\n  once_prop      = 'once',\n  off_prop       = 'off',\n  emit_prop      = '_emit',\n  handlers_prop  = '_handlers',\n} = {}) {\n  \n  let privatehandlers;\n  if (handlers_prop == null) {\n    // Use a truly private storage for event handlers instead of a\n    // publicly accessible one.\n    privatehandlers = {};\n  }\n  \n  return {\n    /**\n    * Associates an event handler function with an event name.\n    *\n    * @function AddEventHandler\n    * @param {String} eventname\n    * @param {EventHandler} callable\n    * @param {Object} [options={}]\n    * @param {String} [options.tag] - Name tag of handler\n    * @param {Number} [options.priority] - Execution order of handlers is sorted\n    * by this number. Higher priority will be sorted first.\n    * @param {Object} [options.context] - Value to use for the first argument of\n    * `Function.call()` when calling `handler`, changing the meaning of `this`\n    * inside `handler`. By default `this` in the `handler` is the object which\n    * emitted the event.\n    * @param {Boolean} [options.once=false] - When `true` then `handler` runs nly\n    * once, then is removed.\n    */\n    [on_prop] (eventname, callable, options={}) {\n      let handler = {\n        callable: callable,\n        tag: options.tag,\n        priority: options.priority || 10,\n        context: options.context || this,\n        once: options.once || false,\n      };\n\n      // Choose and initialize the handlers storage\n      let handlers;\n      if (handlers_prop) {\n        if (!this[handlers_prop]) {\n          // Only ran once.\n          // `this` will be the instance, not the prototype.\n          this[handlers_prop] = {};\n        }\n        handlers = this[handlers_prop];\n      } else {\n        // Use the privately scoped storage instead.\n        handlers = privatehandlers;\n      }\n      \n      if (!handlers[eventname]) {\n        handlers[eventname] = [handler];\n      } else {\n        handlers[eventname].push(handler);\n      }\n      handlers[eventname].sort(function(a, b) {\n        return b.priority - a.priority;\n      });\n    },\n    \n    \n    /**\n    * Same as {@link AddEventHandler}, but sets `options.once` to `true`.\n    *\n    * @function AddOneTimeEventHandler\n    * @alias AddEventHandler\n    */\n    [once_prop] (eventname, callable, options={}) {\n      options.once = true;\n      this[on_prop](eventname, callable, options);\n    },\n    \n    \n    /** \n     * Removes an event handler tagged with `tag` from `eventname`. If `tag` or\n     * `eventname` are not registered, this method does nothing.\n     * \n     * @function RemoveEventHandler\n     * @param {String} eventname\n     * @param {String} tag\n     */\n    [off_prop] (eventname, tag) {\n      // Choose the handlers storage.\n      let handlers;\n      if (handlers_prop) {\n        handlers = this[handlers_prop];\n      } else {\n        handlers = privatehandlers;\n      }\n      \n      if (!tag || !handlers || !handlers[eventname]) {\n        // Nothing to do.\n        return;\n      }\n      \n      let eventhandlers = handlers[eventname];\n      \n      // Find the event handler with matching tag in the array.\n      let i = 0;\n      let found = false;\n      for (let eventhandler of eventhandlers) {\n        if (eventhandler.tag == tag) {\n          found = true;\n          break;\n        }\n        i++;\n      }\n      if (found) {\n        // Remove this handler\n        eventhandlers.splice(i, 1);\n      }\n    },\n    \n    \n    /**\n    * Calls all registered event handler callbacks with the provided arguments.\n    * \n    * Note that return values of event handlers are not visible to\n    * any other event handler, which provides isolation between\n    * event handlers as well as privacy.\n    * \n    * To implement content filtering, you need to pass the content\n    * by reference (i.e. to filter strings, you need to wrap the\n    * string into an object or array).\n    * \n    * @function EmitEvent\n    * @param {String} eventname\n    * @param {...*} args - Arguments to call the handler with.\n    * @returns {Array} - Each return value of handlers concatenated.\n    */\n    [emit_prop] (eventname, ...args) {\n      // Choose the handlers storage.\n      let handlers;\n      if (handlers_prop) {\n        handlers = this[handlers_prop];\n      } else {\n        handlers = privatehandlers;\n      }\n      \n      let retvals = [];\n      if (!handlers || !handlers[eventname]) {\n        // Nothing to do\n        return retvals;\n      }\n      \n      for (let eventhandler of handlers[eventname]) {\n        retvals.push(eventhandler.callable.call(eventhandler.context, ...args));\n      }\n      \n      // remove one-time event handlers\n      for (let i = handlers[eventname].length - 1; i >= 0; i--) {\n        let handler = handlers[eventname][i];\n        if (handler.once) {\n          handlers[eventname].splice(i, 1);\n        }\n      }\n      \n      return retvals;\n    },\n  }; // return\n};\n\nexport default CaptainHook;\n"],"names":["on_prop","once_prop","off_prop","emit_prop","handlers_prop","callable","tag","priority","context","once","push","sort","splice","call","length"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoFA,gBAAkB,UAMV,uEALNA,OAKM,cALW,IAKX,OAJNC,SAIM,cAJW,MAIX,OAHNC,QAGM,cAHW,KAGX,OAFNC,SAEM,cAFW,OAEX,OADNC,aACM,cADW,WACX,GAEF,QAFE,CASN,WANI,GAMJ,GAHE,IAGF,yCAkB8C,iEACtC,EAAU,CACZC,UADY,CAEZC,IAAK,EAAQA,GAFD,CAGZC,SAAU,EAAQA,QAAR,EAAoB,EAHlB,CAIZC,QAAS,EAAQA,OAAR,EAAmB,IAJhB,CAKZC,KAAM,EAAQA,IAAR,IALM,CAD4B,CAUtC,QAVsC,IAYpC,CAAC,OAZmC,GAetC,UAfsC,GAiBxC,EAAW,OAjB6B,EAoBxC,GApBwC,EAuBrC,IAvBqC,CA0BxC,KAAoBC,IAApB,GA1BwC,CAwBxC,KAAsB,GAxBkB,EA4B1C,KAAoBC,IAApB,CAAyB,aAAe,CACtC,SAASJ,QAAF,CAAa,EAAEA,QACvB,CAFD,EAGD,CAjDH,mCA0DgD,iEAC5C,EAAQE,IAAR,GAD4C,EAE5C,eACD,CA7DH,mCAwE8B,CAE1B,KAAA,CAOA,OALa,OAKb,IAAI,MAAsB,IAA1B,EAKA,MAAoB,IAApB,CAGI,EAAI,CAHR,CAII,IAJJ,oBALA,IAUA,+DAAwC,CACtC,cAAI,EAAaH,GAAb,GAAJ,CAA6B,CAC3B,IAD2B,CAE3B,KACD,CACD,IACD,CAhBD,oFAmBE,EAAcM,MAAd,GAAwB,CAAxB,EAnBF,CAqBD,CAtGH,iCAyHmC,CAE/B,QAEa,OAFT,EAAJ,CAOA,QAAA,CACA,GAAI,IAAa,CAAC,IAAlB,CAEE,SAZ6B,yGAe/B,YAAyB,IAAzB,gDAA8C,iBAC5C,EAAQF,IAAR,CAAa,KAAaL,QAAb,EAAsBQ,IAAtB,UAA2B,EAAaL,OAAxC,+BAAb,EACD,CAjB8B,iFAoB/B,IAAK,MAAI,EAAI,KAAoBM,MAApB,CAA6B,CAA1C,CAAkD,CAAL,GAA7C,CAAqD,GAArD,GACgB,OADhB,EAEM,EAAQL,IAFd,EAGI,KAAoBG,MAApB,GAA8B,CAA9B,CAHJ,CAOA,QACD,CArJH,IAuJD,CAtKD;;;;;;;;"}